// Version: 3.2 — Runo Nielsen TDA + Integrated Ls + Inductance Ratio
#include "converter_models/Llc.h"
#include "physical_models/MagnetizingInductance.h"
#include "physical_models/WindingOhmicLosses.h"
#include "support/Utils.h"
#include <cfloat>
#include <cmath>
#include <sstream>
#include <algorithm>
#include "support/Exceptions.h"

namespace OpenMagnetics {

// =====================================================================
// Runo Nielsen Operating Mode Classification
// Reference: http://www.runonielsen.dk/LLC_LCC.pdf
// =====================================================================

enum class LlcOperatingMode {
    MODE_UNDEFINED = 0,
    MODE_BELOW_RESONANCE_LIGHT,
    MODE_NEAR_RESONANCE_LIGHT,
    MODE_ABOVE_RESONANCE_LIGHT,
    MODE_ABOVE_RESONANCE_HEAVY,
    MODE_ABOVE_LIP_CONTINUOUS,
    MODE_OVERLOAD
};

inline const char* mode_to_string(LlcOperatingMode mode) {
    switch(mode) {
        case LlcOperatingMode::MODE_BELOW_RESONANCE_LIGHT: return "Below Resonance (Capacitive)";
        case LlcOperatingMode::MODE_NEAR_RESONANCE_LIGHT: return "Near Resonance (Optimal)";
        case LlcOperatingMode::MODE_ABOVE_RESONANCE_LIGHT: return "Above Resonance (Light Load)";
        case LlcOperatingMode::MODE_ABOVE_RESONANCE_HEAVY: return "Above Resonance (Heavy Load)";
        case LlcOperatingMode::MODE_ABOVE_LIP_CONTINUOUS: return "Above LIP (Continuous Diode)";
        case LlcOperatingMode::MODE_OVERLOAD: return "Overload";
        default: return "Undefined";
    }
}

struct LlcModeAnalysis {
    LlcOperatingMode mode;
    double fn, lip_voltage;
    bool is_below_lip, is_zvs_capable, has_freewheeling;
    std::string description;
};

static LlcModeAnalysis detect_operating_mode(
    double Vi, double Vo, double Po, double fsw, double f0,
    double Ln, double Q, bool isFullBridge)
{
    LlcModeAnalysis a;
    a.fn = (f0 > 0) ? fsw / f0 : 1.0;
    a.lip_voltage = isFullBridge ? Vo : 2.0 * Vo;
    a.is_below_lip = Vi < a.lip_voltage;
    a.is_zvs_capable = a.fn > 1.0;
    a.has_freewheeling = a.is_below_lip;

    if (a.fn < 0.95) {
        a.mode = LlcOperatingMode::MODE_BELOW_RESONANCE_LIGHT;
        a.description = "Capacitive mode (fn < 1). Hard switching - no ZVS!";
    } else if (a.fn <= 1.05 && Q < 0.5) {
        a.mode = LlcOperatingMode::MODE_NEAR_RESONANCE_LIGHT;
        a.description = "Optimal: fn ~ 1, light load, ZVS";
    } else if (a.fn > 1.05 && a.is_below_lip && Q < 0.5) {
        a.mode = LlcOperatingMode::MODE_ABOVE_RESONANCE_LIGHT;
        a.description = "ZVS with freewheeling (Phase A + Phase B)";
    } else if (a.fn > 1.05 && a.is_below_lip) {
        a.mode = LlcOperatingMode::MODE_ABOVE_RESONANCE_HEAVY;
        a.description = "Heavy load: high circulating current";
    } else if (!a.is_below_lip) {
        a.mode = LlcOperatingMode::MODE_ABOVE_LIP_CONTINUOUS;
        a.description = "Above LIP: continuous diode, Phase A only";
    } else {
        a.mode = LlcOperatingMode::MODE_UNDEFINED;
        a.description = "Undefined mode";
    }
    return a;
}

// =====================================================================
// Construction
// =====================================================================
Llc::Llc(const json& j) { from_json(j, *static_cast<LlcResonant*>(this)); }
AdvancedLlc::AdvancedLlc(const json& j) { from_json(j, *this); }

double Llc::get_bridge_voltage_factor() const {
    auto bt = get_bridge_type();
    if (bt.has_value() && bt.value() == LlcBridgeType::FULL_BRIDGE) return 1.0;
    return 0.5;
}

double Llc::get_effective_resonant_frequency() const {
    if (get_resonant_frequency().has_value()) return get_resonant_frequency().value();
    return std::sqrt(get_min_switching_frequency() * get_max_switching_frequency());
}

double Llc::get_inductance_ratio() const {
    // inductance_ratio is autogenerated as double (not optional), so check if valid (> 0)
    double userValue = MAS::LlcResonant::get_inductance_ratio();
    if (userValue > 0) {
        return userValue;
    }
    return computedInductanceRatio;
}

bool Llc::run_checks(bool assertErrors) {
    _assertErrors = assertErrors;
    bool ok = true;
    auto& ops = get_operating_points();
    if (ops.empty()) {
        if (assertErrors) throw std::runtime_error("LLC: no operating points");
        return false;
    }
    for (size_t i = 0; i < ops.size(); i++) {
        auto& op = ops[i];
        if (op.get_output_voltages().empty() || op.get_output_currents().empty()) {
            if (assertErrors) throw std::runtime_error("LLC: OP missing voltages/currents");
            ok = false;
        }
        if (op.get_output_voltages().size() != op.get_output_currents().size()) {
            if (assertErrors) throw std::runtime_error("LLC: voltage/current count mismatch");
            ok = false;
        }
        double fsw = op.get_switching_frequency();
        if (fsw < get_min_switching_frequency() * 0.99 ||
            fsw > get_max_switching_frequency() * 1.01) {
            if (assertErrors) throw std::runtime_error("LLC: fsw out of range");
            ok = false;
        }
    }
    return ok;
}

// =====================================================================
// Design Requirements
//
// LLC has THREE independent design parameters:
//   1. Q  (quality factor)    → controls Ls, Cr (tank impedance)
//   2. Ln (inductance ratio)  → controls Lm (magnetizing inductance)
//   3. fr (resonant frequency) → sets the operating frequency
//
// From these:
//   Rac = 8·n²/(π²) · Rload
//   Zr  = Q · Rac
//   Ls  = Zr / (2π·fr)
//   Cr  = 1 / (2π·fr·Zr)
//   Lm  = Ln · Ls
// =====================================================================
DesignRequirements Llc::process_design_requirements() {
    double k_bridge = get_bridge_voltage_factor();
    auto& inputVoltage = get_input_voltage();
    double Vin_nom = inputVoltage.get_nominal().value_or(
        (inputVoltage.get_minimum().value_or(0) + inputVoltage.get_maximum().value_or(0)) / 2.0);
    auto& ops = get_operating_points();
    double mainOutputVoltage  = ops[0].get_output_voltages()[0];
    double mainOutputCurrent  = ops[0].get_output_currents()[0];

    double Vo = k_bridge * Vin_nom;
    double mainTurnsRatio = Vo / mainOutputVoltage;

    std::vector<double> turnsRatios;
    turnsRatios.push_back(mainTurnsRatio);
    for (size_t i = 1; i < ops[0].get_output_voltages().size(); i++)
        turnsRatios.push_back(Vo / ops[0].get_output_voltages()[i]);

    double Rload = mainOutputVoltage / mainOutputCurrent;
    double Rac = (8.0 * mainTurnsRatio * mainTurnsRatio) / (M_PI * M_PI) * Rload;
    double Q = get_quality_factor().value_or(0.4);
    double fr = get_effective_resonant_frequency();
    double Zr = Q * Rac;
    double Ls = Zr / (2.0 * M_PI * fr);
    double Cr = 1.0 / (2.0 * M_PI * fr * Zr);

    // Inductance ratio: user-settable via JSON, falls back to computedInductanceRatio
    // Low Ln (3-5):  wide gain range, high magnetizing current, good ZVS margin
    // Medium (5-8):  balanced design
    // High Ln (8-12): narrow gain, low magnetizing current, high efficiency
    double Ln = get_inductance_ratio();
    double L = Ln * Ls;

    std::cout << "LLC Design Parameters:" << std::endl;
    std::cout << "  Q  = " << Q << (get_quality_factor().has_value() ? " (user)" : " (default)") << std::endl;
    std::cout << "  Ln = " << Ln << " (user)" << std::endl;
    std::cout << "  fr = " << (fr/1e3) << " kHz" << std::endl;
    std::cout << "  Ls = " << (Ls*1e6) << " uH, Cr = " << (Cr*1e9) << " nF, Lm = " << (L*1e6) << " uH" << std::endl;

    if (Ln < 2.0 || Ln > 20.0)
        std::cerr << "WARNING: Ln=" << Ln << " outside typical range [3, 12]." << std::endl;

    computedResonantInductance  = Ls;
    computedResonantCapacitance = Cr;

    if (inputVoltage.get_minimum().has_value() && inputVoltage.get_maximum().has_value()) {
        double Vin_min = inputVoltage.get_minimum().value();
        double Vin_max = inputVoltage.get_maximum().value();
        double M_req_min = (mainOutputVoltage * mainTurnsRatio) / (k_bridge * Vin_min);
        double M_req_max = (mainOutputVoltage * mainTurnsRatio) / (k_bridge * Vin_max);
        double M_max_noload = (Ln > 1.0) ? std::sqrt(Ln / (Ln - 1.0)) : 10.0;
        double M_max_heavy = M_max_noload / std::sqrt(1.0 + Q * Q * std::pow(M_max_noload * M_max_noload - 1.0, 2));
        if (M_req_min > M_max_heavy)
            std::cerr << "WARNING: Cannot achieve gain M=" << M_req_min << " at Vin_min=" << Vin_min
                      << "V (max=" << M_max_heavy << "). Reduce Ln or increase fsw." << std::endl;
        if (M_req_max < 0.3)
            std::cerr << "WARNING: Gain too low at Vin_max=" << Vin_max << "V (M=" << M_req_max << ")." << std::endl;
    }

    {
        double Coss_est = 200e-12;
        double td_min_zvs = (M_PI / 2.0) * std::sqrt(2.0 * Coss_est * L);
        if (computedDeadTime < td_min_zvs)
            std::cerr << "WARNING: Dead time (" << (computedDeadTime*1e9)
                      << "ns) < min ZVS (" << (td_min_zvs*1e9) << "ns)" << std::endl;
    }

    DesignRequirements designRequirements;
    designRequirements.get_mutable_turns_ratios().clear();
    for (auto n : turnsRatios) {
        DimensionWithTolerance nTol;
        nTol.set_nominal(roundFloat(n, 2));
        designRequirements.get_mutable_turns_ratios().push_back(nTol);
    }
    DimensionWithTolerance inductanceWithTolerance;
    inductanceWithTolerance.set_nominal(roundFloat(L, 10));
    designRequirements.set_magnetizing_inductance(inductanceWithTolerance);

    if (get_integrated_resonant_inductor().value_or(false)) {
        std::vector<DimensionWithTolerance> leakageReqs;
        DimensionWithTolerance lrTol;
        lrTol.set_nominal(roundFloat(Ls, 10));
        leakageReqs.push_back(lrTol);
        designRequirements.set_leakage_inductance(leakageReqs);
    }
    return designRequirements;
}

// =====================================================================
// Process operating points
// =====================================================================
std::vector<OperatingPoint> Llc::process_operating_points(
    const std::vector<double>& turnsRatios, double magnetizingInductance)
{
    if (computedResonantInductance <= 0 || computedResonantCapacitance <= 0)
        process_design_requirements();

    std::vector<OperatingPoint> result;
    auto& inputVoltage = get_input_voltage();
    auto& ops = get_operating_points();
    std::vector<std::pair<double, std::string>> inputVoltages;
    if (inputVoltage.get_nominal().has_value())
        inputVoltages.push_back({inputVoltage.get_nominal().value(), "Nominal"});
    if (inputVoltage.get_minimum().has_value())
        inputVoltages.push_back({inputVoltage.get_minimum().value(), "Min"});
    if (inputVoltage.get_maximum().has_value())
        inputVoltages.push_back({inputVoltage.get_maximum().value(), "Max"});

    std::sort(inputVoltages.begin(), inputVoltages.end(),
        [](const auto& a, const auto& b) { return a.first < b.first; });
    auto last = std::unique(inputVoltages.begin(), inputVoltages.end(),
        [](const auto& a, const auto& b) { return a.first == b.first; });
    inputVoltages.erase(last, inputVoltages.end());

    for (const auto& [Vin, name] : inputVoltages) {
        auto op = process_operating_point_for_input_voltage(
            Vin, ops[0], turnsRatios, magnetizingInductance);
        op.set_name(name + " input (" + std::to_string(static_cast<int>(Vin)) + "V)");
        result.push_back(op);
    }
    return result;
}

std::vector<OperatingPoint> Llc::process_operating_points(Magnetic magnetic) {
    auto req = process_design_requirements();
    std::vector<double> turnsRatios;
    for (auto& tr : req.get_turns_ratios())
        turnsRatios.push_back(resolve_dimensional_values(tr));
    double Lm = resolve_dimensional_values(req.get_magnetizing_inductance());
    return process_operating_points(turnsRatios, Lm);
}

// =====================================================================
// CORE SIMULATION — Runo Nielsen Time Domain Approach
// =====================================================================

struct LlcSimulationResult {
    bool has_freewheeling;
    double freewheeling_time;
    double transition_time;
    double iLm_at_turnon;
};

static LlcSimulationResult simulate_positive_half_cycle(
    double ILs0, double IL0, double Vc0,
    double Vi, double Vo, double L,
    double w1, double Z1, double w0, double Z0,
    double Thalf_eff, int N, double dt,
    std::vector<double>& ILs_pos, std::vector<double>& IL_pos,
    std::vector<double>& Vc_pos, std::vector<double>& VL_pos,
    double& ILs_end, double& IL_end, double& Vc_end)
{
    LlcSimulationResult result;
    result.has_freewheeling = false;
    result.freewheeling_time = 0.0;
    result.transition_time = Thalf_eff;
    result.iLm_at_turnon = IL0;

    bool in_freewheeling = false;
    double t_fw = Thalf_eff, ILs_fw = 0, Vc_fw = 0;

    for (int k = 0; k <= N; ++k) {
        double t = k * dt;
        double ILs_t, IL_t, Vc_t, VL_t;

        if (!in_freewheeling) {
            double V_drive = Vi - Vo;
            ILs_t = ILs0 * std::cos(w1 * t)
                   + (V_drive - Vc0) / Z1 * std::sin(w1 * t);
            Vc_t = V_drive
                 - (V_drive - Vc0) * std::cos(w1 * t)
                 + ILs0 * Z1 * std::sin(w1 * t);
            IL_t = IL0 + (Vo / L) * t;
            VL_t = Vo;

            double Id = ILs_t - IL_t;
            if (Id < 0 && t > Thalf_eff * 0.05) {
                in_freewheeling = true;
                t_fw = t;
                result.has_freewheeling = true;
                result.transition_time = t_fw;
                ILs_fw = 0.5 * (ILs_t + IL_t);
                Vc_fw = Vc_t;
            }
        }

        if (in_freewheeling) {
            double tau = t - t_fw;
            ILs_t = ILs_fw * std::cos(w0 * tau)
                   + (Vi - Vc_fw) / Z0 * std::sin(w0 * tau);
            Vc_t = Vi - (Vi - Vc_fw) * std::cos(w0 * tau)
                 + ILs_fw * Z0 * std::sin(w0 * tau);
            IL_t = ILs_t;
            double dILs_dt = -ILs_fw * w0 * std::sin(w0 * tau)
                           + (Vi - Vc_fw) / Z0 * w0 * std::cos(w0 * tau);
            VL_t = L * dILs_dt;
        }

        if (!std::isfinite(ILs_t)) ILs_t = ILs0;
        if (!std::isfinite(IL_t))  IL_t  = IL0;
        if (!std::isfinite(Vc_t))  Vc_t  = 0;
        if (!std::isfinite(VL_t))  VL_t  = 0;

        ILs_pos[k] = ILs_t;
        IL_pos[k]  = IL_t;
        Vc_pos[k]  = Vc_t;
        VL_pos[k]  = VL_t;

        if (k == N) { ILs_end = ILs_t; IL_end = IL_t; Vc_end = Vc_t; }
    }

    if (result.has_freewheeling)
        result.freewheeling_time = Thalf_eff - result.transition_time;
    return result;
}


OperatingPoint Llc::process_operating_point_for_input_voltage(
    double inputVoltage,
    const LlcOperatingPoint& llcOpPoint,
    const std::vector<double>& turnsRatios,
    double magnetizingInductance)
{
    OperatingPoint operatingPoint;

    double fsw = llcOpPoint.get_switching_frequency();
    if (fsw <= 0) {
        fsw = get_effective_resonant_frequency();
        if (fsw <= 0) fsw = 100000.0;
    }

    double k_bridge = get_bridge_voltage_factor();
    bool isFullBridge = (get_bridge_type().has_value() &&
                         get_bridge_type().value() == LlcBridgeType::FULL_BRIDGE);
    bool integratedLs = get_integrated_resonant_inductor().value_or(false);

    double Vi = k_bridge * inputVoltage;
    double Vo = turnsRatios[0] * llcOpPoint.get_output_voltages()[0];

    if (magnetizingInductance <= 0) magnetizingInductance = 200e-6;

    double Ls = computedResonantInductance;
    double C  = computedResonantCapacitance;
    double L  = magnetizingInductance;

    if (Ls <= 0 || C <= 0) {
        double fr = get_effective_resonant_frequency();
        double Q_val = get_quality_factor().value_or(0.4);
        double Ln_val = get_inductance_ratio();
        double Vout = llcOpPoint.get_output_voltages()[0];
        double Iout_fb = llcOpPoint.get_output_currents()[0];
        double Rload = (Iout_fb > 0) ? Vout / Iout_fb : 100.0;
        double Rac = (8.0 * turnsRatios[0] * turnsRatios[0]) / (M_PI * M_PI) * Rload;
        double Zr = Q_val * Rac;
        Ls = Zr / (2.0 * M_PI * fr);
        C = 1.0 / (2.0 * M_PI * fr * Zr);
        L = Ln_val * Ls;
        computedResonantInductance = Ls;
        computedResonantCapacitance = C;
    }

    if (Ls <= 0 || C <= 0 || L <= 0)
        throw std::runtime_error("LLC resonant tank values invalid.");

    // --- RUNO NIELSEN MODE DETECTION ---
    {
        double f0_det = 1.0 / (2.0 * M_PI * std::sqrt(Ls * C));
        double Ln_det = L / Ls;
        double Q_det = get_quality_factor().value_or(0.4);
        double Po_det = llcOpPoint.get_output_voltages()[0] * llcOpPoint.get_output_currents()[0];

        LlcModeAnalysis modeAnalysis = detect_operating_mode(
            Vi, Vo, Po_det, fsw, f0_det, Ln_det, Q_det, isFullBridge);

        std::cout << "\n" << std::string(70, '=') << std::endl;
        std::cout << "LLC MODE ANALYSIS (Runo Nielsen TDA)" << std::endl;
        std::cout << std::string(70, '=') << std::endl;
        std::cout << "Mode: " << mode_to_string(modeAnalysis.mode) << std::endl;
        std::cout << "  " << modeAnalysis.description << std::endl;
        std::cout << "  fn = " << modeAnalysis.fn << " (fsw=" << fsw << " / f0=" << f0_det << ")" << std::endl;
        std::cout << "  Ln = " << Ln_det << ", Q = " << Q_det << std::endl;
        std::cout << "  LIP = " << modeAnalysis.lip_voltage << " V, Vi = " << Vi << " V "
                  << (modeAnalysis.is_below_lip ? "(below)" : "(above)") << std::endl;
        std::cout << "  ZVS: " << (modeAnalysis.is_zvs_capable ? "YES" : "NO")
                  << "  Freewheeling: " << (modeAnalysis.has_freewheeling ? "YES" : "NO")
                  << "  Integrated Ls: " << (integratedLs ? "YES" : "NO") << std::endl;
        std::cout << std::string(70, '=') << std::endl;

        if (modeAnalysis.mode == LlcOperatingMode::MODE_BELOW_RESONANCE_LIGHT)
            std::cerr << "WARNING: Below resonance — NO ZVS!" << std::endl;
        if (modeAnalysis.mode == LlcOperatingMode::MODE_ABOVE_RESONANCE_HEAVY)
            std::cerr << "WARNING: Heavy load — high circulating current." << std::endl;
    }

    if (Vo >= Vi)
        std::cerr << "WARNING: Vo (" << Vo << "V) >= Vi (" << Vi << "V)." << std::endl;

    double period = 1.0 / fsw;
    double Thalf  = period / 2.0;
    double deadTime = computedDeadTime;
    double Thalf_eff = Thalf - deadTime;
    if (Thalf_eff <= 0) { Thalf_eff = Thalf; deadTime = 0; }

    double w1 = 1.0 / std::sqrt(Ls * C);
    double Z1 = std::sqrt(Ls / C);
    double w0 = 1.0 / std::sqrt((Ls + L) * C);
    double Z0 = std::sqrt((Ls + L) / C);

    if (!std::isfinite(w1) || w1 <= 0) w1 = 2.0 * M_PI * 100000.0;
    if (!std::isfinite(Z1) || Z1 <= 0) Z1 = 10.0;
    if (!std::isfinite(w0) || w0 <= 0) w0 = w1 * 0.7;
    if (!std::isfinite(Z0) || Z0 <= 0) Z0 = Z1 * 1.5;

    const int N = 256;
    double dt = Thalf_eff / N;

    if (!std::isfinite(Vo) || Vo < 0) Vo = 1.0;
    if (!std::isfinite(Thalf_eff) || Thalf_eff <= 0) Thalf_eff = 5e-6;
    if (!std::isfinite(L) || L <= 0) L = 200e-6;

    double Im_pk_est = Vo * Thalf_eff / (2.0 * L);
    if (!std::isfinite(Im_pk_est) || std::abs(Im_pk_est) > 1e6)
        Im_pk_est = std::copysign(1.0, Im_pk_est);

    double Iout = llcOpPoint.get_output_currents()[0];
    double n_eff = turnsRatios.empty() ? (Vi / llcOpPoint.get_output_voltages()[0]) : turnsRatios[0];
    if (n_eff <= 0) n_eff = 1.0;
    double Iload_reflected = Iout / n_eff;

    double Ires_est = std::max(std::abs(Im_pk_est) + std::abs(Iload_reflected),
                               Iload_reflected * 1.5);

    double ILs0 = -Ires_est;
    double IL0  = -Im_pk_est;

    const int MAX_OUTER = 20;
    const double TOL_I = 1e-4;
    const int MAX_BISECT = 60;
    const double TOL_VC = 1e-4;

    std::vector<double> ILs_pos(N + 1, 0.0), IL_pos(N + 1, 0.0);
    std::vector<double> Vc_pos(N + 1, 0.0), VL_pos(N + 1, 0.0);
    double Vc0 = 0.0;

    LlcSimulationResult simResult;

    for (int outer = 0; outer < MAX_OUTER; ++outer) {
        IL0 = ILs0;
        double Vc_lo = -3.0 * Vi, Vc_hi = 3.0 * Vi;
        double ILs_end = 0, IL_end = 0, Vc_end = 0;

        for (int bisect = 0; bisect < MAX_BISECT; ++bisect) {
            Vc0 = 0.5 * (Vc_lo + Vc_hi);
            simResult = simulate_positive_half_cycle(
                ILs0, IL0, Vc0, Vi, Vo, L,
                w1, Z1, w0, Z0, Thalf_eff, N, dt,
                ILs_pos, IL_pos, Vc_pos, VL_pos,
                ILs_end, IL_end, Vc_end);

            double err_vc = Vc_end + Vc0;
            if (std::abs(err_vc) < TOL_VC) break;
            if (err_vc > 0) Vc_hi = Vc0; else Vc_lo = Vc0;
        }
        double err_i = ILs_end + ILs0;
        if (std::abs(err_i) < TOL_I) break;
        ILs0 = -ILs_end;
    }

    std::cout << "\nSimulation Results:" << std::endl;
    std::cout << "  Freewheeling: " << (simResult.has_freewheeling ? "YES" : "NO") << std::endl;
    if (simResult.has_freewheeling)
        std::cout << "  Freewheeling: " << (simResult.freewheeling_time * 1e6)
                  << " us (" << (simResult.freewheeling_time / Thalf_eff * 100.0) << "%)" << std::endl;
    std::cout << "  iLm at turn-on: " << simResult.iLm_at_turnon << " A" << std::endl;

    // =====================================================================
    // Build full-period waveforms
    //
    // Primary voltage depends on Ls topology:
    //   SEPARATE Ls:   Vpri = VLm(t) — flat clamp + soft hill (magnetizing only)
    //   INTEGRATED Ls: Vpri = Vi - Vc(t) — bridge voltage with Cr ripple
    // =====================================================================

    int totalSamples = 2 * N + 1;
    std::vector<double> time_full(totalSamples);
    std::vector<double> ILs_full(totalSamples);
    std::vector<double> IL_full(totalSamples);
    std::vector<double> Vpri_full(totalSamples);  // Primary voltage (topology-dependent)
    std::vector<double> VLm_full(totalSamples);   // Magnetizing voltage (for core loss & secondary)

    for (int k = 0; k <= N; ++k) {
        time_full[k] = k * dt;
        ILs_full[k] = std::isfinite(ILs_pos[k]) ? ILs_pos[k] : ILs0;
        IL_full[k]  = std::isfinite(IL_pos[k])  ? IL_pos[k]  : IL0;

        double VLm_k = std::isfinite(VL_pos[k]) ? VL_pos[k] : 0.0;
        double Vc_k  = std::isfinite(Vc_pos[k]) ? Vc_pos[k] : 0.0;
        VLm_full[k] = VLm_k;

        if (integratedLs) {
            Vpri_full[k] = Vi - Vc_k;
        } else {
            Vpri_full[k] = VLm_k;
        }
    }

    for (int k = 1; k <= N; ++k) {
        time_full[N + k] = Thalf_eff + k * dt;
        ILs_full[N + k] = std::isfinite(ILs_pos[k]) ? -ILs_pos[k] : -ILs0;
        IL_full[N + k]  = std::isfinite(IL_pos[k])  ? -IL_pos[k]  : -IL0;

        double VLm_k = std::isfinite(VL_pos[k]) ? VL_pos[k] : 0.0;
        double Vc_k  = std::isfinite(Vc_pos[k]) ? Vc_pos[k] : 0.0;
        VLm_full[N + k] = -VLm_k;

        if (integratedLs) {
            Vpri_full[N + k] = -(Vi - Vc_k);
        } else {
            Vpri_full[N + k] = -VLm_k;
        }
    }

    if (integratedLs) {
        double Vpmax = *std::max_element(Vpri_full.begin(), Vpri_full.end());
        double Vpmin = *std::min_element(Vpri_full.begin(), Vpri_full.end());
        std::cout << "  Integrated Ls: Vpri = Vi - Vc(t), range [" << Vpmin << ", " << Vpmax << "] V" << std::endl;
    } else {
        std::cout << "  Separate Ls: Vpri = VLm(t) (flat clamp + soft hill)" << std::endl;
    }
    std::cout << std::string(70, '=') << "\n" << std::endl;

    // --- Primary excitation ---
    {
        Waveform currentWaveform;
        currentWaveform.set_ancillary_label(WaveformLabel::CUSTOM);
        currentWaveform.set_data(ILs_full);
        currentWaveform.set_time(time_full);

        Waveform voltageWaveform;
        voltageWaveform.set_ancillary_label(WaveformLabel::CUSTOM);
        voltageWaveform.set_data(Vpri_full);
        voltageWaveform.set_time(time_full);

        auto excitation = complete_excitation(currentWaveform, voltageWaveform,
                                              fsw, "Primary");
        operatingPoint.get_mutable_excitations_per_winding().push_back(excitation);
    }

    // --- Secondary excitation ---
    // Secondary always sees VLm/n (leakage doesn't couple to secondary)
    std::vector<double> effectiveTurnsRatios = turnsRatios;
    if (effectiveTurnsRatios.empty()) {
        effectiveTurnsRatios.push_back(Vi / llcOpPoint.get_output_voltages()[0]);
    }

    for (size_t secIdx = 0; secIdx < effectiveTurnsRatios.size(); ++secIdx) {
        double n = effectiveTurnsRatios[secIdx];
        if (n <= 0) { n = Vi / llcOpPoint.get_output_voltages()[secIdx]; if (n <= 0) n = 1.0; }

        std::vector<double> iSecData(totalSamples, 0.0);
        std::vector<double> vSecData(totalSamples, 0.0);

        for (int k = 0; k < totalSamples; ++k) {
            double Id = ILs_full[k] - IL_full[k];
            if (!std::isfinite(Id)) Id = 0;
            iSecData[k] = std::abs(Id) / n;
            vSecData[k] = VLm_full[k] / n;
            if (!std::isfinite(iSecData[k])) iSecData[k] = 0;
            if (!std::isfinite(vSecData[k])) vSecData[k] = 0;
        }

        Waveform secCurrentWfm;
        secCurrentWfm.set_ancillary_label(WaveformLabel::CUSTOM);
        secCurrentWfm.set_data(iSecData);
        secCurrentWfm.set_time(time_full);

        Waveform secVoltageWfm;
        secVoltageWfm.set_ancillary_label(WaveformLabel::CUSTOM);
        secVoltageWfm.set_data(vSecData);
        secVoltageWfm.set_time(time_full);

        auto excitation = complete_excitation(secCurrentWfm, secVoltageWfm,
                                              fsw, "Secondary " + std::to_string(secIdx));
        operatingPoint.get_mutable_excitations_per_winding().push_back(excitation);
    }

    OperatingConditions conditions;
    conditions.set_ambient_temperature(llcOpPoint.get_ambient_temperature());
    conditions.set_cooling(std::nullopt);
    operatingPoint.set_conditions(conditions);

    return operatingPoint;
}


// =====================================================================
// SPICE Circuit Generation
// =====================================================================
std::string Llc::generate_ngspice_circuit(
    const std::vector<double>& turnsRatios,
    double magnetizingInductance,
    size_t inputVoltageIndex,
    size_t operatingPointIndex)
{
    auto& inputVoltageSpec = get_input_voltage();
    auto& ops = get_operating_points();

    std::vector<double> inputVoltages;
    if (inputVoltageSpec.get_nominal().has_value())
        inputVoltages.push_back(inputVoltageSpec.get_nominal().value());
    if (inputVoltageSpec.get_minimum().has_value())
        inputVoltages.push_back(inputVoltageSpec.get_minimum().value());
    if (inputVoltageSpec.get_maximum().has_value())
        inputVoltages.push_back(inputVoltageSpec.get_maximum().value());

    double inputVoltage = inputVoltages[std::min(inputVoltageIndex, inputVoltages.size() - 1)];
    auto& llcOp = ops[std::min(operatingPointIndex, ops.size() - 1)];

    double fsw = llcOp.get_switching_frequency();
    double period = 1.0 / fsw;
    double halfPeriod = period / 2.0;
    double deadTime = computedDeadTime;
    double tOn = halfPeriod - deadTime;
    double Vout = llcOp.get_output_voltages()[0];
    double Iout = llcOp.get_output_currents()[0];
    double n = turnsRatios[0];
    double Ls = computedResonantInductance;
    double Cr = computedResonantCapacitance;
    double L  = magnetizingInductance;

    bool isFullBridge = (get_bridge_type().has_value() &&
                         get_bridge_type().value() == LlcBridgeType::FULL_BRIDGE);
    bool integratedLs = get_integrated_resonant_inductor().value_or(false);

    int numPeriodsTotal = get_num_steady_state_periods() + get_num_periods_to_extract();
    double simTime = numPeriodsTotal * period;
    double startTime = get_num_steady_state_periods() * period;
    double maxStep = period / 200.0;
    double Rload = (Iout > 0) ? (Vout / Iout) : 100.0;

    std::ostringstream circuit;

    circuit << "* LLC Resonant Converter v3.2 (" << (integratedLs ? "Integrated Ls" : "Separate Ls") << ")\n";
    circuit << "* " << (isFullBridge ? "Full" : "Half") << "-Bridge\n";
    circuit << "* Vin=" << inputVoltage << "V  fsw=" << (fsw/1e3) << "kHz  Vout=" << Vout << "V\n";
    circuit << "* Ls=" << (Ls*1e6) << "uH  Cr=" << (Cr*1e9) << "nF  Lm=" << (L*1e6) << "uH  n=" << n << "\n\n";

    if (isFullBridge) {
        circuit << "Vbridge bridge_a bridge_b PULSE("
                << -inputVoltage << " " << inputVoltage << " 0 "
                << std::scientific << deadTime << " " << deadTime << " "
                << tOn << " " << period << std::fixed << ")\n";
        circuit << "Vpri_sense bridge_a lr_in 0\n";
        circuit << "Vbus_gnd bridge_b 0 0\n\n";
    } else {
        circuit << "Vbridge sw_node mid_point PULSE("
                << -(inputVoltage / 2.0) << " " << (inputVoltage / 2.0) << " 0 "
                << std::scientific << deadTime << " " << deadTime << " "
                << tOn << " " << period << std::fixed << ")\n";
        circuit << "Vmid mid_point 0 0\n";
        circuit << "Vpri_sense sw_node lr_in 0\n\n";
    }

    if (integratedLs) {
        double Lpri_total = L + Ls;
        double k_int = std::sqrt(L / Lpri_total);
        double Lsec_half = Lpri_total / (n * n);

        circuit << "* Resonant cap (no separate inductor — leakage provides Ls)\n";
        circuit << "Cr lr_in pri_top " << std::scientific << Cr << "\n\n";
        circuit << "* Transformer: Lpri=Lm+Ls=" << (Lpri_total*1e6) << "uH, k=" << k_int << "\n";
        circuit << "Lpri pri_top pri_bot " << std::scientific << Lpri_total << "\n";
        circuit << "Lsec1 sec_top sec_ct " << std::scientific << Lsec_half << "\n";
        circuit << "Lsec2 sec_ct sec_bot " << std::scientific << Lsec_half << "\n";
        circuit << "K1 Lpri Lsec1 Lsec2 " << k_int << "\n\n";
    } else {
        double Lsec_half = L / (n * n);
        circuit << "* Resonant tank (separate inductor)\n";
        circuit << "Cr lr_in cr_ls " << std::scientific << Cr << "\n";
        circuit << "Lr cr_ls pri_top " << std::scientific << Ls << "\n\n";
        circuit << "* Transformer (k=0.999)\n";
        circuit << "Lpri pri_top pri_bot " << std::scientific << L << "\n";
        circuit << "Lsec1 sec_top sec_ct " << std::scientific << Lsec_half << "\n";
        circuit << "Lsec2 sec_ct sec_bot " << std::scientific << Lsec_half << "\n";
        circuit << "K1 Lpri Lsec1 Lsec2 0.999\n\n";
    }

    if (isFullBridge) circuit << "Rpri_ret pri_bot bridge_b 0.001\n\n";
    else              circuit << "Rpri_ret pri_bot mid_point 0.001\n\n";

    circuit << ".model DRECT D(Is=1e-8 N=0.01 RS=0.01)\n";
    circuit << "D1 sec_top vout_pos DRECT\n";
    circuit << "D2 sec_bot vout_pos DRECT\n";
    circuit << "Rsn1 sec_top vout_pos 100\nCsn1 sec_top vout_pos 100p\n";
    circuit << "Rsn2 sec_bot vout_pos 100\nCsn2 sec_bot vout_pos 100p\n";
    circuit << "Vsec_sense sec_ct vout_neg 0\nVgnd vout_neg 0 0\n\n";

    circuit << "Resr vout_pos vout_cap 0.05\n";
    circuit << "Cout vout_cap vout_neg " << std::scientific << 47e-6 << "\n";
    circuit << "Rload vout_cap vout_neg " << Rload << "\n\n";

    circuit << ".ic v(vout_cap)=" << Vout << " v(cr_ls)=0\n\n";
    circuit << ".options RELTOL=0.01 ABSTOL=1e-7 VNTOL=1e-4 ITL1=300 ITL4=100\n";
    circuit << ".options METHOD=GEAR TRTOL=7\n\n";
    circuit << ".tran " << std::scientific << maxStep << " " << simTime
            << " " << startTime << " " << maxStep << " UIC\n\n";
    circuit << ".save v(pri_top) v(pri_bot) v(sec_top) v(sec_bot) v(vout_pos) v(vout_neg) v(vout_cap)";
    circuit << " i(Vpri_sense) i(Vsec_sense)\n\n.end\n";

    return circuit.str();
}


// =====================================================================
// SPICE simulation wrappers
// =====================================================================
std::vector<OperatingPoint> Llc::simulate_and_extract_operating_points(
    const std::vector<double>& turnsRatios, double magnetizingInductance)
{
    std::vector<OperatingPoint> operatingPoints;
    NgspiceRunner runner;
    if (!runner.is_available())
        return process_operating_points(turnsRatios, magnetizingInductance);

    std::vector<double> inputVoltages;
    if (get_input_voltage().get_nominal().has_value())
        inputVoltages.push_back(get_input_voltage().get_nominal().value());
    if (get_input_voltage().get_minimum().has_value())
        inputVoltages.push_back(get_input_voltage().get_minimum().value());
    if (get_input_voltage().get_maximum().has_value())
        inputVoltages.push_back(get_input_voltage().get_maximum().value());

    auto& ops = get_operating_points();
    for (size_t vinIdx = 0; vinIdx < inputVoltages.size(); ++vinIdx) {
        for (size_t opIdx = 0; opIdx < ops.size(); ++opIdx) {
            std::string netlist = generate_ngspice_circuit(turnsRatios, magnetizingInductance, vinIdx, opIdx);
            double switchingFrequency = ops[opIdx].get_switching_frequency();

            SimulationConfig config;
            config.frequency = switchingFrequency;
            config.extractOnePeriod = true;
            config.numberOfPeriods = get_num_periods_to_extract();
            config.keepTempFiles = false;

            auto simResult = runner.run_simulation(netlist, config);
            if (!simResult.success) {
                std::cerr << "LLC sim failed: " << simResult.errorMessage << ". Falling back." << std::endl;
                return process_operating_points(turnsRatios, magnetizingInductance);
            }

            NgspiceRunner::WaveformNameMapping waveformMapping;
            waveformMapping.push_back({{"voltage", "pri_top"}, {"current", "vpri_sense#branch"}});
            waveformMapping.push_back({{"voltage", "sec_top"}, {"current", "vsec_sense#branch"}});
            std::vector<std::string> windingNames = {"Primary", "Secondary"};
            std::vector<bool> flipCurrentSign = {false, true};

            OperatingPoint operatingPoint = NgspiceRunner::extract_operating_point(
                simResult, waveformMapping, switchingFrequency, windingNames,
                ops[opIdx].get_ambient_temperature(), flipCurrentSign);

            std::string vinName = (vinIdx == 0) ? "Nominal" : (vinIdx == 1 ? "Min" : "Max");
            operatingPoint.set_name(vinName + " input (" +
                std::to_string(static_cast<int>(inputVoltages[vinIdx])) + "V)");
            operatingPoints.push_back(operatingPoint);
        }
    }
    return operatingPoints;
}


std::vector<ConverterWaveforms> Llc::simulate_and_extract_topology_waveforms(
    const std::vector<double>& turnsRatios, double magnetizingInductance, size_t numberOfPeriods)
{
    std::vector<ConverterWaveforms> results;
    NgspiceRunner runner;
    if (!runner.is_available())
        throw std::runtime_error("ngspice is not available");

    int originalNumPeriods = get_num_periods_to_extract();
    set_num_periods_to_extract(static_cast<int>(numberOfPeriods));
    auto ops = get_operating_points();

    for (size_t opIdx = 0; opIdx < ops.size(); ++opIdx) {
        std::string netlist = generate_ngspice_circuit(turnsRatios, magnetizingInductance, 0, opIdx);
        double switchingFrequency = ops[opIdx].get_switching_frequency();

        SimulationConfig config;
        config.frequency = switchingFrequency;
        config.extractOnePeriod = true;
        config.numberOfPeriods = numberOfPeriods;
        config.keepTempFiles = false;

        auto simResult = runner.run_simulation(netlist, config);
        if (!simResult.success)
            throw std::runtime_error("LLC simulation failed: " + simResult.errorMessage);

        std::map<std::string, size_t> nameToIndex;
        for (size_t i = 0; i < simResult.waveformNames.size(); ++i) {
            std::string lower = simResult.waveformNames[i];
            std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
            nameToIndex[lower] = i;
        }
        auto getWf = [&](const std::string& name) -> Waveform {
            std::string lower = name;
            std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
            auto it = nameToIndex.find(lower);
            return (it != nameToIndex.end()) ? simResult.waveforms[it->second] : Waveform();
        };

        ConverterWaveforms wf;
        wf.set_switching_frequency(switchingFrequency);
        wf.set_operating_point_name("LLC op. point " + std::to_string(opIdx));
        wf.set_input_voltage(getWf("pri_top"));
        wf.set_input_current(getWf("vpri_sense#branch"));

        if (!turnsRatios.empty()) {
            auto vp = getWf("vout_pos"); auto vn = getWf("vout_neg");
            if (!vp.get_data().empty() && !vn.get_data().empty()) {
                auto vpd = vp.get_data(); auto vnd = vn.get_data();
                std::vector<double> vd; vd.reserve(vpd.size());
                for (size_t i = 0; i < vpd.size() && i < vnd.size(); ++i)
                    vd.push_back(vpd[i] - vnd[i]);
                Waveform voutWf = vp; voutWf.set_data(vd);
                wf.get_mutable_output_voltages().push_back(voutWf);
            }
            auto iout = getWf("vsec_sense#branch");
            if (!iout.get_data().empty())
                wf.get_mutable_output_currents().push_back(iout);
        }
        results.push_back(wf);
    }
    set_num_periods_to_extract(originalNumPeriods);
    return results;
}


// =====================================================================
// AdvancedLlc
// =====================================================================
Inputs AdvancedLlc::process() {
    auto designRequirements = process_design_requirements();
    designRequirements.get_mutable_turns_ratios().clear();
    for (auto n : desiredTurnsRatios) {
        DimensionWithTolerance nTol; nTol.set_nominal(n);
        designRequirements.get_mutable_turns_ratios().push_back(nTol);
    }
    DimensionWithTolerance LmTol; LmTol.set_nominal(desiredMagnetizingInductance);
    designRequirements.set_magnetizing_inductance(LmTol);
    auto ops = process_operating_points(desiredTurnsRatios, desiredMagnetizingInductance);
    Inputs inputs;
    inputs.set_design_requirements(designRequirements);
    inputs.set_operating_points(ops);
    return inputs;
}

} // namespace OpenMagnetics
